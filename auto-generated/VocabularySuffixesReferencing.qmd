
### Referencing Suffixes

 Several variables are used to filter, identify or locate particular rows in a table or across multiple tables. Below, we list and clarify the ones we use and how we use them.

<br>*_id	[string]
: if a column name is postfix with `_id` (e.g., `participant_id`, `task_id`) it is expected that there exists a table which has the same name (i.e., "participant", "task), with a primary key named `id` such that a value of in the first (`particiapant_id = 215`) refers to an entry in the second (a row in the participant table where `id = 215`). It is expected that the values in a variable postfixed `_id` are unique within a "local scope" (e.g., a dataset); however, it is not expected that they are unique globallyâ€”for such purposes one should use the `_uuid`.
: If there is a column named `id` (i.e., without prefix) it is expected that there are other data tables or files that refer to this column; if such a link does not exist, use `index` instead.
Finally, the postfix `_id` does not imply a particular value format: both integers and strings are valid formats. 



*_name	[string]
: Sometimes "name" is used in a way that is similar to id (e.g., `study_name` or `task_name`).
The difference between `_id` and `_name` is that `_name` is expected to be a readable string (e.g., `n-back` versus "f346-r23v"). As with `_id`, it is expected that name refers to other data tables and that names are unique within a certain context (contrary to `*_label`).



*_uuid	[string]
: Universally Unique Identifier (https://en.wikipedia.org/wiki/Universally_unique_identifier) is a 128-bit number that can be generated on the fly and will most likely be unique. uuid can be used to assign a row a unique id without having to ensure that that number is not yet used by some other table.
: _uuid are expected to be unique (globally); 
: _uuid are not expected to be human readable; 
: **Example**: `123e4567-e89b-12d3-a456-426614174000`

:::{.callout-note}

 ISO/IEC 11578:1996 

:::


:::{.callout-note}

 We don't use uid 

:::



*_hash	[string]
: sometimes it is useful to create a key by combining other keys. A hash is not strictly necessary as it can be recreated using other variables but it can be convenient for data processing.
https://en.wikipedia.org/wiki/Hash_function 
: There is not a single standard for hashing; rather there are multiple algorithms that can be used. We use both CRC32 (32 hexadecimal characters; e.g., "098f6bcd4621d373cade4e832627b4f6") and SHA256 (base64 characters, e.g., "d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f"); depending on the probability of collision (i.e., two hashes being identical); when that probability is deemed high, we use SHA256.



*_index	[integer]
: index should be favored when a variable is used for referencing and when order is important (often, but not always the chronological order).  For example, "stimulus_position_index" implies its value points to an entry in a list of possible stimulus_positions. Note that "index" typically implies a context within which the indexing occurs and that context must be made explicit. For example, trial_index may index trials within a block or a timeline.

:::{.callout-note}

 Here we follow the convention of always starting counting/indexing from 1 (rather than 0). 

:::


:::{.callout-note}

 We avoid the use of `*_number` because it is ambiguous. 

:::



*_repetition	[integer]
: is used to count the number of times the same "thing" occurred (e.g., a participant completes the same test twice, the same stimulus appears multiple times). As with index, repetition assumes a context which must be clarified when ambiguous. 

:::{.callout-note}

 Repetition starts "counting" at 0 rather than 1; *_iteration instead of *_repetition would solve this issue but is less explicit and thus less preferred. 

:::



*_label	[string]
: an text attached to a variable; expected to be human readable, but not unique. 



